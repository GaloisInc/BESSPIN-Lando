{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE StandaloneDeriving #-}

{-|
Module      : Lobot.TypeCheck.Types
Description : Some Haskell types used during LOBOT type checking.
Copyright   : (c) Matt Yacavone, 2020
License     : BSD3
Maintainer  : myac@galois.com
Stability   : experimental
Portability : POSIX

This module defines a number of Haskell types used while type checking the Lobot AST.
-}

module Lobot.TypeCheck.Types where

import qualified Data.HashMap as H
import qualified Data.HashSet as HS
import qualified Text.PrettyPrint as PP

import Data.Text (Text)
import Control.Monad (foldM_)
import Control.Monad.Trans (lift)
import Control.Monad.State (StateT, get, evalStateT)
import Data.Parameterized.BoolRepr
import Data.Parameterized.Some
import Data.Parameterized.Context
import Prelude hiding (zipWith, unzip)

import Lobot.Lexer (AlexPosn, errorPrefix)
import Lobot.Syntax as S
import Lobot.Types as T
import Lobot.Pretty as P
import Lobot.Syntax.Pretty as S


data DerivedConstraint = FromKind LText
                       | FromField LText [DerivedConstraint]
                       deriving Show

type IExpr     = ExprP (Some TypeRepr, [DerivedConstraint])
type ILiteral  = LiteralP (Some TypeRepr, [DerivedConstraint])
type ILExpr    = Loc IExpr
type ILLiteral = Loc ILiteral

data IKind = IKind { ikindType ::  Some T.TypeRepr
                   , ikindConstraints :: [ILExpr]
                   , ikindDerivedConstraints :: [DerivedConstraint]
                   } deriving Show

data IFunctionType = IFunType { ifunType :: Some FunctionTypeRepr
                              , ifunArgConstraints :: [[DerivedConstraint]]
                              , ifunRetConstraints :: [DerivedConstraint]
                              } deriving Show


type CtxM t err = StateT (H.Map Text t) (Either err)

evalCtxM :: CtxM t err a -> Either err a
evalCtxM x = evalStateT x H.empty

try :: CtxM t err a -> CtxM t err (Either err a)
try x = evalStateT x <$> get

typeError :: TypeError -> CtxM t TypeError a
typeError = lift . Left

ensureUnique :: (a -> Text) -> [a] -> (a -> TypeError) -> CtxM t TypeError ()
ensureUnique f xs err =
  foldM_ (\xset x -> if (f x) `HS.notMember` xset
                     then pure $ HS.insert (f x) xset
                     else typeError (err x)) HS.empty xs


-- | All type errors that can be generated by the typechecker.
data TypeError = TypeMismatchError S.LExpr SomeTypeOrString (Maybe SomeTypeOrString)
                 -- ^ argument order: expr, expected type, actual type
               | AbstractEqualityError S.LExpr SomeTypeOrString
               | TypeInferenceError S.LExpr
               | DuplicateEnumNameError S.LType Text
               | EmptyEnumOrSetError S.LType
               | KindUnionMismatchError LText (Some T.TypeRepr) (Some T.TypeRepr)
                 -- ^ argument order: kind name, expected type, actual type
               | KindNameNotInScope LText
               | FunctionNameNotInScope LText
               | FieldNameNotInScope LText
               | EnumNameNotInScope LText
               | KindNameAlreadyDefined LText
               | FunctionNameAlreadyDefined LText
               | FieldNameAlreadyDefined LText
               | FunctionArgLengthError LText (Some FunctionTypeRepr) [S.LExpr]
               | InternalError AlexPosn Text
               deriving Show

ppTypeError :: FilePath -> TypeError -> PP.Doc
ppTypeError fp (TypeMismatchError (L p x) exp_tp Nothing) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Type mismatch on expression:" PP.<+> S.ppExpr x
  PP.$$ PP.nest 2 (PP.text "Expected type:") PP.<+> PP.nest 6 (ppSomeTypeOrString exp_tp)
ppTypeError fp (TypeMismatchError x exp_tp (Just act_tp)) =
  ppTypeError fp (TypeMismatchError x exp_tp Nothing)
  PP.$$ PP.nest 2 (PP.text "  Actual type:") PP.<+> PP.nest 6 (ppSomeTypeOrString act_tp)
ppTypeError fp (AbstractEqualityError (L p x) tp) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Equality comparison on abstract type:" PP.<+> ppSomeTypeOrString tp
  PP.$$ PP.nest 2 (PP.text "  In expression:" PP.<+> S.ppExpr x)
ppTypeError fp (TypeInferenceError (L p x)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Could not infer the type of expression:" PP.<+> S.ppExpr x
ppTypeError fp (DuplicateEnumNameError (L p tp) nm) =
  PP.text (errorPrefix fp p)
  PP.<+> S.ppText nm PP.<+> PP.text "appears more than once in the enum or set:" PP.<+> S.ppType tp
ppTypeError fp (EmptyEnumOrSetError (L p tp)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Empty enum or set:" PP.<+> S.ppType tp
ppTypeError fp (KindUnionMismatchError (L p k) (Some exp_tp) (Some act_tp)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "In a kind union, type mismatch on kind name:" PP.<+> S.ppText k
  PP.$$ PP.nest 2 (PP.text "Expected type:") PP.<+> PP.nest 6 (ppTypeRepr exp_tp)
  PP.$$ PP.nest 2 (PP.text "  Actual type:") PP.<+> PP.nest 6 (ppTypeRepr act_tp)
ppTypeError fp (KindNameNotInScope (L p k)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Kind name" PP.<+> S.ppText k PP.<+> PP.text "not in scope."
ppTypeError fp (FunctionNameNotInScope (L p fn)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Function name" PP.<+> S.ppText fn PP.<+> PP.text "not in scope."
ppTypeError fp (FieldNameNotInScope (L p f)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Field name" PP.<+> S.ppText f PP.<+> PP.text "not in scope."
ppTypeError fp (EnumNameNotInScope (L p fn)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Enum name" PP.<+> S.ppText fn PP.<+> PP.text "not in scope."
ppTypeError fp (KindNameAlreadyDefined (L p k)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "A kind with name" PP.<+> S.ppText k PP.<+> PP.text "is already defined."
ppTypeError fp (FunctionNameAlreadyDefined (L p fn)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "A function with name" PP.<+> S.ppText fn PP.<+> PP.text "is already defined."
ppTypeError fp (FieldNameAlreadyDefined (L p f)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "A field with name" PP.<+> S.ppText f PP.<+> PP.text "is already in scope."
ppTypeError fp (FunctionArgLengthError (L p fn) (Some (FunctionTypeRepr{..})) args) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Function" PP.<+> S.ppText fn
  PP.<+> PP.text "expects" PP.<+> PP.int (sizeInt . size $ functionArgTypes)
  PP.<+> PP.text "arguments, but was given" PP.<+> PP.int (length args)
ppTypeError fp (InternalError p str) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Internal error!" PP.$$ PP.nest 2 (S.ppText str)

data SomeTypeOrString :: * where
  SomeType   :: T.TypeRepr tp -> SomeTypeOrString
  TypeString :: Text -> SomeTypeOrString
deriving instance Show SomeTypeOrString

ppSomeTypeOrString :: SomeTypeOrString -> PP.Doc
ppSomeTypeOrString (SomeType tp) = ppTypeRepr tp
ppSomeTypeOrString (TypeString s) = S.ppText s
