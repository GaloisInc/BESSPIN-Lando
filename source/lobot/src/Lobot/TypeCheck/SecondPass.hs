{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}

{-|
Module      : Lobot.TypeCheck.SecondPass
Description : The second pass of typechecking the Lobot AST.
Copyright   : (c) Matthew Yacavone, 2020
License     : BSD3
Maintainer  : myac@galois.com
Stability   : experimental
Portability : POSIX

This module exposes the first pass of the type checking algorithm for the
Lobot AST. This consists of taking the intermediate declarations generated by
the first pass and type checking all constraints, resolving all derived
constraints into type checked constraints from previously checked kinds, and
scope-checking kind, function, and enum names in constraints, the last of
which is driven by the enum names determined to be in scope in each
intermediate declaration. Note that although all function declarations have
already been visited in the first pass, we revisit each in this pass only to
add its name to the list of in-scope function names, for the purposes of
reporting errors if a function name is mentioned before it's defined. We add
kind names to scope as they're visited in this pass for the same reason.

The result of this pass a list of fully typed kinds in the given function
environment and a list of fully typed checks in the given function environment.

-}

module Lobot.TypeCheck.SecondPass
  ( secondPass
  ) where

import qualified Data.HashMap.Strict as H
import qualified Data.HashSet as HS

import Data.Text (Text, append)
import Data.List (union, (\\))
import Data.Maybe (catMaybes)
import Data.Functor.Const
import Control.Monad (unless, forM_)
import Control.Monad.State (get, modify)
import Control.Monad.Except (throwError, catchError)
import Data.Parameterized.BoolRepr
import Data.Parameterized.Some
import Data.Parameterized.Pair
import Data.Parameterized.Classes
import Data.Parameterized.Context hiding (null)
import Data.Parameterized.NatRepr
import Data.Parameterized.SymbolRepr
import Data.Parameterized.TraversableFC

import Lobot.Utils
import Prelude hiding (unzip, zipWith)

import Lobot.Expr as E
import Lobot.Kind as K
import Lobot.Syntax as S
import Lobot.Types as T

import Lobot.TypeCheck.Monad
import Lobot.TypeCheck.IDecls as I
import Lobot.TypeCheck.FirstPass (tcType)


-- | Run the second pass of type checking on a function environment and a list
-- of intermediate declarations, producing a list of fully typed kinds in the
-- given function environment and a list of fully typed checks in the given
-- function environment.
secondPass :: Assignment FunctionTypeRepr env
           -> [I.Decl]
           -> WithWarnings (Either TypeError)
                           ( [Some (K.Kind env)]
                           , [Some (K.Check env)]
                           , [Some (K.ConstrainedFunction env)] )
secondPass env ds = evalTCM $ tcDecls env ds


-- | For this pass, the type of kind/check constraints is simply a list of
-- fully typed expressions of boolean type.
newtype P2Cns env ctx = P2Cns [E.Expr env ctx BoolType]

-- | The 'TCM' used in the second pass.
type TCM2 env = TCM (P2Cns env) TypeError


addKind :: Text -> K.Kind env tp -> EnumNameSet -> TCM2 env ()
addKind nm (K.Kind _ tp _ cns) enms =
  -- We don't bother to check if the given kind name is already in scope, as
  -- all 'KindNameAlreadyDefined' errors should have already been caught in
  -- the first pass
  modify (H.insert nm (NamedKind tp (P2Cns cns) (not (null cns)) enms))

addFunction :: Text -> ConstrainedFunction env tp
            -> [EnumNameSet] -> EnumNameSet -> TCM2 env ()
addFunction nm (K.CFun (T.FunctionTypeRepr _ arg_tps ret_tp)
                       arg_nms arg_cns ret_cns) arg_enms ret_enms = do
  -- We don't bother to check if the given function name is already in scope,
  -- as all 'FunctionNameAlreadyDefined' errors should have already been
  -- caught in the first pass
  modify (H.insert nm (NamedFunction arg_tps ret_tp (P2Cns arg_cns) (P2Cns ret_cns)
                                                    arg_enms ret_enms arg_nms))

-- | Unlike 'lookupKindType', in this pass we can now return a fully type
-- checked kind given an in-scope kind name
lookupKind :: Assignment T.FunctionTypeRepr env
           -> LText -> TCM2 env (Some (K.Kind env))
lookupKind env (L p k) = do
  mb_k' <- H.lookup k <$> get
  case mb_k' of
    Just (NamedKind tp (P2Cns cns) _ _) -> pure (Some (K.Kind k tp env cns))
    _ -> throwError (KindNameNotInScope (L p k))

data FunctionLookup env where
  FunLookup :: Index env ftp -> K.ConstrainedFunction env ftp
            -> [EnumNameSet] -> EnumNameSet -> FunctionLookup env

-- | Given an in-scope function name, return its index into the given function
-- environment, its associated constrained function declaration, and the list
-- of enum names which each argument type should bring into scope.
lookupFunction :: Assignment T.FunctionTypeRepr env
               -> LText -> TCM2 env (FunctionLookup env)
lookupFunction env (L p fn) = do
  mb_fn' <- H.lookup fn <$> get
  case mb_fn' of
    Just (NamedFunction arg_tps ret_tp (P2Cns arg_cns) (P2Cns ret_cns)
                        arg_enms ret_enms arg_nms)
      | Some fn' <- someSymbol fn
      , ftp <- T.FunctionTypeRepr fn' arg_tps ret_tp
      , cfn <- K.CFun ftp arg_nms arg_cns ret_cns 
      , Just fi <- elemIndex ftp env
      -> pure $ FunLookup fi cfn arg_enms ret_enms
    _ -> throwError (FunctionNameNotInScope (L p fn))


-- | Fully type check a list of intermediate declarations
tcDecls :: Assignment FunctionTypeRepr env
        -> [I.Decl]
        -> TCM2 env ( [Some (K.Kind env)]
                    , [Some (K.Check env)]
                    , [Some (K.ConstrainedFunction env)] )
tcDecls _ [] = pure ([],[],[])
tcDecls env (d:ds) = do
  mb_d' <- tcDecl env d
  (ks, cks, cfns) <- tcDecls env ds
  case mb_d' of
    Nothing -> pure (ks, cks, cfns)
    Just (CheckedKind k)   -> pure (k:ks, cks, cfns)
    Just (CheckedCheck ck) -> pure (ks, ck:cks, cfns)
    Just (CheckedFun cfn)  -> pure (ks, cks, cfn:cfns)

data CheckedDecl env = CheckedKind (Some (K.Kind env))
                     | CheckedCheck (Some (K.Check env))
                     | CheckedFun (Some (K.ConstrainedFunction env))

-- | Fully type check an intermediate declaration
tcDecl :: Assignment FunctionTypeRepr env
       -> I.Decl
       -> TCM2 env (Maybe (CheckedDecl env))
tcDecl env (I.KindDecl ik) =
  Just . CheckedKind <$> tcKind env ik
tcDecl env (I.CheckDecl ick) =
  Just . CheckedCheck <$> tcCheck env ick
tcDecl env (I.TypeSynDecl nm (Some tp) enms) = do
  tcDecl env (I.KindDecl (I.Kind nm tp [] [] enms))
tcDecl env (I.FunctionDecl ifn) = do
  Just . CheckedFun <$> tcConstrainedFunction env ifn 

-- | Fully type check an intermediate kind declaration
tcKind :: Assignment FunctionTypeRepr env
       -> I.Kind
       -> TCM2 env (Some (K.Kind env))
tcKind env (I.Kind (L _ nm) tp cns dcns enms) = do
  cns'  <- mapM (tcExpr enms env (singleton $ SelfElem tp) T.BoolRepr) cns
  dcns' <- concat <$> mapM (resolveDerivedConstraint env tp) dcns
  let k' = K.Kind nm tp env (cns' ++ dcns')
  addKind nm k' enms
  pure $ Some k'

-- | Fully type check an intermediate check declaration
tcCheck :: forall env .
           Assignment FunctionTypeRepr env
        -> I.Check
        -> TCM2 env (Some (K.Check env))
tcCheck env (I.Check (L _ nm) flds cns reqs enms) = do
  let tps = fmapFC (\(I.CheckField (S.L _ nm') tp _) -> VarElem nm' tp) flds
  cns'  <- mapM (tcExpr enms env tps T.BoolRepr) cns
  let collectDCs :: Index tps tp -> CheckField tp
                 -> TCM2 env [E.Expr env tps 'T.BoolType]
      collectDCs i (CheckField _ tp dcns) = do
        kes <- concat <$> mapM (resolveDerivedConstraint env tp) dcns
        return $ giveSelf (E.VarExpr i) <$> kes
  dcns' <- traverseAndCollect collectDCs flds
  reqs' <- mapM (tcExpr enms env tps T.BoolRepr) reqs
  let namedTypes = fmapFC (\(CheckField (S.L _ fnm) tp _) -> NamedType fnm tp) flds
  let ck' = K.Check nm namedTypes env (cns' ++ dcns') reqs'
  pure $ Some ck'

-- | Fully type check a function declaration.
tcConstrainedFunction :: forall env.
                         Assignment FunctionTypeRepr env
                      -> I.FunctionType
                      -> TCM2 env (Some (ConstrainedFunction env))
tcConstrainedFunction env (I.FunType (L _ nm) arg_tps ret_tp arg_dcns
                                     ret_dcns arg_enms ret_enms) = do
  Some nm' <- pure $ someSymbol nm
  let collectDCs :: Assignment TypeRepr args
                 -> Index args tp -> Const [DerivedConstraint] tp
                 -> TCM2 env [E.Expr env args 'T.BoolType]
      collectDCs arg_tps' i (Const dcns) = do
        let tp = arg_tps' ! i
        kes <- concat <$> mapM (resolveDerivedConstraint env tp) dcns
        return $ giveSelf (E.VarExpr i) <$> kes
  arg_dcns' <- traverseAndCollect (collectDCs arg_tps) arg_dcns
  ret_dcns' <- concat <$> mapM (resolveDerivedConstraint env ret_tp) ret_dcns
  let cfn = K.CFun (T.FunctionTypeRepr nm' arg_tps ret_tp)
                   (fmapFC (\_ -> Const "_") arg_tps) arg_dcns' ret_dcns'
  addFunction nm cfn arg_enms ret_enms
  pure $ Some cfn

-- | Using the given context of fully checked kinds, turn a
-- 'DerivedConstraint' into a list of type checked expressions in the
-- appropriate scope.
-- NOTE: Maybe we want to do something more type-directed here in the future...
resolveDerivedConstraint :: Assignment T.FunctionTypeRepr env
                         -> T.TypeRepr tp
                         -> DerivedConstraint
                         -> TCM2 env [K.KindExpr env tp T.BoolType]

resolveDerivedConstraint env tp (FromKind (L p nm)) = do
  Some k <- lookupKind env (L p nm)
  case testEquality tp (K.kindType k) of
    Just Refl -> pure $ K.kindConstraints k
    _ -> throwError . InternalError p $
           "Malformed derived constraint: FromKind " `append` nm

resolveDerivedConstraint env tp (FromField (L p f) ds)
  | T.StructRepr ftps <- tp
  , Just (Some idx) <- findIndex (\(FieldRepr f' _) -> f == symbolRepr f') ftps
  , FieldRepr _ ftp <- ftps ! idx
    = do ds' <- concat <$> mapM (resolveDerivedConstraint env ftp) ds
         pure $ fmap (giveSelf (E.FieldExpr K.SelfExpr idx)) ds'
  | otherwise
    = throwError . InternalError p $
        "Malformed derived constraint: FromField " `append` f



-- * Type inference and checking for expressions

-- | Instead of just providing an 'Assignment' of 'TypeRepr's to 'tcInferExpr'
-- to represent the in-scope type context, we also indicate whether each
-- represents @self@ or not, and in the latter case, provide the variable's
-- name. When calling this function from a kind, the single in-scope variable
-- should be marked with 'SelfElem', and otherwise 'VarElem' should always be
-- used.
data ContextElem (tp :: T.Type) where
  SelfElem :: T.TypeRepr tp -> ContextElem tp
  VarElem  :: Text -> T.TypeRepr tp -> ContextElem tp

-- | Return the result of calling the given predicate if the given
-- 'ContextElem' is a 'VarElem', otherwise return false.
ifVarElem :: (Text -> T.TypeRepr tp -> Bool) -> ContextElem tp -> Bool
ifVarElem f (VarElem nm tp) = f nm tp
ifVarElem _ _ = False

-- | Return the set of additional enums which should be brought into scope
-- when the given expression is part of a binary operation, e.g. @=@ or @in@.
-- This is nonempty only when the given expression is a function application,
-- a non-anonymous struct expression, or a field expression on any of these
-- expressions. Using this function ensures that cases like the following do
-- not give enum name out of scope warnings:
-- 
-- @
-- abstract f : int -> { A, B, C }
-- 
-- ... f(n) = B ...
-- @
addlEnms :: Assignment T.FunctionTypeRepr env
         -> S.LExpr -> TCM2 env EnumNameSet
addlEnms env (L _ (S.ApplyExpr fn _)) = do
  FunLookup _ _ _ ret_enms <- lookupFunction env fn
  pure ret_enms
addlEnms _ (L _ (S.StructExpr (Just tp) _)) =
  (\(_,_,enms) -> enms) <$> tcType tp
addlEnms env (L _ (S.FieldExpr x _)) = addlEnms env x
addlEnms _ _ = pure HS.empty

-- | Infer the type of an expression without any knowledge of what its type
-- should be. In cases where the inferred type is open (see
-- 'InferredTypeRepr'), there should be a corresponding case in 'tcExpr'.
tcInferExpr :: EnumNameSet
            -> Assignment T.FunctionTypeRepr env
            -> Assignment ContextElem ctx
            -> S.LExpr
            -> TCM2 env (Pair InferredTypeRepr (E.Expr env ctx))

tcInferExpr _ _ _ (L _ (S.BoolLit b)) =
  pure $ Pair ClosedBoolRepr (E.LiteralExpr (E.BoolLit b))

tcInferExpr _ _ _ (L _ (S.IntLit z))  =
  pure $ Pair ClosedIntRepr  (E.LiteralExpr (E.IntLit z))

-- the inferred type of an enum literal is left open, thus this has a
-- corresponding case in 'tcExpr'
tcInferExpr enms _ _ (L _ (S.EnumLit (L p e))) = do
  unless (e `HS.member` enms) $ emitWarning (EnumNameNotInScope (L p e))
  Some e' <- pure $ someSymbol e 
  pure $ Pair (OpenEnumRepr (Empty :> e'))
              (E.LiteralExpr (E.EnumLit (Empty :> e') baseIndex))

-- the inferred type of a set literal is left open, thus this has a
-- corresponding case in 'tcExpr'. Note that this case also has strange
-- behavior if @es == []@, see 'fromEnumNameList' and 'enumSetIndices'
tcInferExpr enms _ _ (L _ (S.SetLit es)) = do
  forM_ es $ \(L p e) ->
    unless (e `HS.member` enms) $ emitWarning (EnumNameNotInScope (L p e))
  Pair es' NonEmpty <- pure $ fromEnumNameList (someSymbol . unLoc <$> es)
  pure $ Pair (OpenSetRepr es')
              (E.LiteralExpr (E.SetLit es' (enumSetIndices es')))

-- in the case of an anonymous struct expression, we simply infer the types of
-- all of its fields. Since the resulting type is open if any of its inferred
-- field types are, this has a corresponding case in 'tcExpr'
tcInferExpr enms env ctx (L _ (S.StructExpr Nothing fvs)) = do
  Pair iftps fvs' <- unzip <$> mapM (tcInferField enms env ctx) fvs
  pure $ Pair (infStructRepr iftps) (E.structExpr fvs')

-- in the case of a non-anonymous struct expression, we type check its fields
-- against the field types of the given type
tcInferExpr enms env ctx (L p (S.StructExpr (Just tp) fvs)) = do
  tcType tp >>= \case
    (Some (T.StructRepr ftps), [], enms')
     -> do
      mfvs' <- tcFields (enms `HS.union` enms') env ctx ftps (reverse fvs)
      case mfvs' of
         Just fvs' -> pure $ Pair (closed (T.StructRepr ftps))
                                  (E.structExpr fvs')
         Nothing ->
           throwError (StructExprLengthError p (Some ftps) (fst <$> fvs))
    _ -> throwError (StructExprTypeError tp)

tcInferExpr enms env ctx (L p (S.VarExpr t))
  -- if t is an enum:
  | unLoc t `HS.member` enms
    = tcInferExpr enms env ctx (L p (S.EnumLit t))
  -- if we're in a `kind of struct` context and t is a field name:
  | (Empty :> SelfElem (T.StructRepr ftps)) <- ctx
  , Just (Some i) <- findIndex (\(FieldRepr f _) -> unLoc t == symbolRepr f) ftps
  , FieldRepr _ tp <- ftps ! i
    = pure $ Pair (closed tp) (E.FieldExpr (E.VarExpr baseIndex) i)
  -- if t is a variable name from the current context:
  | Just (Some i) <- findIndex (ifVarElem (\nm _ -> unLoc t == nm)) ctx
  , VarElem _ tp <- ctx ! i
    = pure $ Pair (closed tp) (E.VarExpr i)
  -- otherwise, we error
  | otherwise
    = throwError (OtherNameNotInScope t)

-- @self@ is only permitted in a kind context (one consisting only of @self@)
tcInferExpr _ _ ctx (L p S.SelfExpr)
  | (Empty :> SelfElem tp) <- ctx = pure $ Pair (closed tp) K.SelfExpr
  | otherwise                     = throwError (UnexpectedSelfError p)

-- the type of @x.f@ is left open if the inferred type corresponding to @f@ in
-- the type of @x@ is open, thus this has a corresponding case in 'tcExpr'
tcInferExpr enms env ctx (L _ (S.FieldExpr x (L p f))) = do
  Pair (InfTp xtpc xtp) x' <- tcInferExpr enms env ctx x
  Some f' <- pure $ someSymbol f
  case (xtpc, xtp) of
    (ClStruct ftpcs, StructRepr ftps) ->
      case getFieldIndex f' (zipWith InfFTp ftpcs ftps) of
        Just (FieldIndex _ itp i) -> pure $ Pair itp (E.FieldExpr x' i)
        Nothing -> throwError (NoSuchFieldError (L p f) x (Some xtp))
    _ -> throwError (TypeMismatchError x (TypeString "a struct")
                                         (Just $ SomeType xtp))

tcInferExpr enms env ctx (L _ (S.ApplyExpr fn args)) = do
  FunLookup fi _ arg_enms _ <- lookupFunction env fn
  fntp@FunctionTypeRepr{..} <- pure $ env ! fi
  mb_args' <-
    tcExprs enms env ctx functionArgTypes (reverse (zip args arg_enms))
  case mb_args' of
    Just args' -> pure $ Pair (closed functionRetType) (E.ApplyExpr fi args')
    Nothing -> throwError (FunctionArgLengthError fn (Some fntp) args)

tcInferExpr enms env ctx (L _ (S.EqExpr x y)) = do
  x_enms <- HS.union enms <$> addlEnms env y
  y_enms <- HS.union enms <$> addlEnms env x
  Pair xitp@(InfTp _ xtp) x' <- tcInferExpr x_enms env ctx x
  Pair yitp@(InfTp _ ytp) y' <- tcInferExpr y_enms env ctx y
  -- ensure that @x@ and @y@ both have non-abstract types
  case (isNonAbstract xtp, isNonAbstract ytp) of
    (Just IsNonAbs, Just IsNonAbs) -> do
      -- ensure that @x@ and @y@ both have the same type
      SameExprType _ x'' y'' <- unifyExprTypes env ctx (xitp, x', x_enms, x)
                                                       (yitp, y', y_enms, y)
      pure $ Pair ClosedBoolRepr (E.EqExpr x'' y'')
    (Nothing, _) -> throwError (AbstractEqualityError x (SomeType xtp))
    (_, Nothing) -> throwError (AbstractEqualityError y (SomeType ytp))
-- this is entirely the same as the above
tcInferExpr enms env ctx (L _ (S.NeqExpr x y)) = do
  x_enms <- HS.union enms <$> addlEnms env y
  y_enms <- HS.union enms <$> addlEnms env x
  Pair xitp@(InfTp _ xtp) x' <- tcInferExpr x_enms env ctx x
  Pair yitp@(InfTp _ ytp) y' <- tcInferExpr y_enms env ctx y
  -- ensure that @x@ and @y@ both have non-abstract types
  case (isNonAbstract xtp, isNonAbstract ytp) of
    (Just IsNonAbs, Just IsNonAbs) -> do
      -- ensure that @x@ and @y@ both have the same type
      SameExprType _ x'' y'' <- unifyExprTypes env ctx (xitp, x', x_enms, x)
                                                       (yitp, y', y_enms, y)
      pure $ Pair ClosedBoolRepr (E.NeqExpr x'' y'')
    (Nothing, _) -> throwError (AbstractEqualityError x (SomeType xtp))
    (_, Nothing) -> throwError (AbstractEqualityError y (SomeType ytp))

tcInferExpr enms env ctx (L _ (S.LteExpr x y)) = do
  x' <- tcExpr enms env ctx T.IntRepr x
  y' <- tcExpr enms env ctx T.IntRepr y
  pure $ Pair ClosedBoolRepr (E.LteExpr x' y')
tcInferExpr enms env ctx (L _ (S.LtExpr x y)) = do
  x' <- tcExpr enms env ctx T.IntRepr x
  y' <- tcExpr enms env ctx T.IntRepr y
  pure $ Pair ClosedBoolRepr (E.LtExpr x' y')
tcInferExpr enms env ctx (L _ (S.GteExpr x y)) = do
  x' <- tcExpr enms env ctx T.IntRepr x
  y' <- tcExpr enms env ctx T.IntRepr y
  pure $ Pair ClosedBoolRepr (E.GteExpr x' y')
tcInferExpr enms env ctx (L _ (S.GtExpr x y)) = do
  x' <- tcExpr enms env ctx T.IntRepr x
  y' <- tcExpr enms env ctx T.IntRepr y
  pure $ Pair ClosedBoolRepr (E.GtExpr x' y')
tcInferExpr enms env ctx (L _ (S.PlusExpr x y)) = do
  x' <- tcExpr enms env ctx T.IntRepr x
  y' <- tcExpr enms env ctx T.IntRepr y
  pure $ Pair ClosedIntRepr (E.PlusExpr x' y')
tcInferExpr enms env ctx (L _ (S.MinusExpr x y)) = do
  x' <- tcExpr enms env ctx T.IntRepr x
  y' <- tcExpr enms env ctx T.IntRepr y
  pure $ Pair ClosedIntRepr (E.MinusExpr x' y')
tcInferExpr enms env ctx (L _ (S.TimesExpr x y)) = do
  x' <- tcExpr enms env ctx T.IntRepr x
  y' <- tcExpr enms env ctx T.IntRepr y
  pure $ Pair ClosedIntRepr (E.TimesExpr x' y')
tcInferExpr enms env ctx (L _ (S.ModExpr x y)) = do
  x' <- tcExpr enms env ctx T.IntRepr x
  y' <- tcExpr enms env ctx T.IntRepr y
  pure $ Pair ClosedIntRepr (E.ModExpr x' y')
tcInferExpr enms env ctx (L _ (S.DivExpr x y)) = do
  x' <- tcExpr enms env ctx T.IntRepr x
  y' <- tcExpr enms env ctx T.IntRepr y
  pure $ Pair ClosedIntRepr (E.DivExpr x' y')
tcInferExpr enms env ctx (L _ (S.AbsExpr x)) = do
  x' <- tcExpr enms env ctx T.IntRepr x
  pure $ Pair ClosedIntRepr (E.AbsExpr x')
tcInferExpr enms env ctx (L _ (S.NegExpr x)) = do
  x' <- tcExpr enms env ctx T.IntRepr x
  pure $ Pair ClosedIntRepr (E.NegExpr x')

tcInferExpr enms env ctx (L _ (S.MemberExpr x y)) = do
  x_enms <- HS.union enms <$> addlEnms env y
  y_enms <- HS.union enms <$> addlEnms env x
  Pair (InfTp xtpc xtp) x' <- tcInferExpr x_enms env ctx x
  Pair (InfTp ytpc ytp) y' <- tcInferExpr y_enms env ctx y
  -- ensure that @x@ is an enum and @y@ is a set
  case (xtpc, xtp, ytpc, ytp) of
    (ClEnum xIsCl, T.EnumRepr xcs, ClSet yIsCl, T.SetRepr ycs) -> do
      -- ensure that the types of @x@ and @y@ use the same set of enum names
      SameEnumType _ _ x'' y'' <-
        unifyEnumTypes env ctx (xIsCl, xcs, x', x_enms, x, EnumCon T.EnumRepr)
                               (yIsCl, ycs, y', y_enms, y, EnumCon T.SetRepr)
      pure $ Pair ClosedBoolRepr (E.MemberExpr x'' y'')
    -- error accordingly if either @x@ isn't an enum or @y@ isn't a set
    (_, T.EnumRepr _, _, _) ->
      throwError (TypeMismatchError y (TypeString "a set")
                                      (Just $ SomeType ytp))
    (_,_,_,_) -> throwError (TypeMismatchError x (TypeString "an enum")
                                                 (Just $ SomeType xtp))
-- this is entirely the same as the above
tcInferExpr enms env ctx (L _ (S.NotMemberExpr x y)) = do
  x_enms <- HS.union enms <$> addlEnms env y
  y_enms <- HS.union enms <$> addlEnms env x
  Pair (InfTp xtpc xtp) x' <- tcInferExpr x_enms env ctx x
  Pair (InfTp ytpc ytp) y' <- tcInferExpr y_enms env ctx y
  -- ensure that @x@ is an enum and @y@ is a set
  case (xtpc, xtp, ytpc, ytp) of
    (ClEnum xIsCl, T.EnumRepr xcs, ClSet yIsCl, T.SetRepr ycs) -> do
      -- ensure that the types of @x@ and @y@ use the same set of enum names
      SameEnumType _ _ x'' y'' <-
        unifyEnumTypes env ctx (xIsCl, xcs, x', x_enms, x, EnumCon T.EnumRepr)
                               (yIsCl, ycs, y', y_enms, y, EnumCon T.SetRepr)
      pure $ Pair ClosedBoolRepr (E.NotMemberExpr x'' y'')
    -- error accordingly if either @x@ isn't an enum or @y@ isn't a set
    (_, T.EnumRepr _, _, _) ->
      throwError (TypeMismatchError y (TypeString "a set")
                                      (Just $ SomeType ytp))
    (_,_,_,_) -> throwError (TypeMismatchError x (TypeString "an enum")
                                                 (Just $ SomeType xtp))
-- this is mostly the same as both of the above
tcInferExpr enms env ctx (L _ (S.SubsetExpr x y)) = do
  x_enms <- HS.union enms <$> addlEnms env y
  y_enms <- HS.union enms <$> addlEnms env x
  Pair (InfTp xtpc xtp) x' <- tcInferExpr x_enms env ctx x
  Pair (InfTp ytpc ytp) y' <- tcInferExpr y_enms env ctx y
  -- ensure that @x@ and @y@ are both sets
  case (xtpc, xtp, ytpc, ytp) of
    (ClSet xIsCl, T.SetRepr xcs, ClSet yIsCl, T.SetRepr ycs) -> do
      -- ensure that the types of @x@ and @y@ use the same set of enum names
      SameEnumType _ _ x'' y'' <-
        unifyEnumTypes env ctx (xIsCl, xcs, x', x_enms, x, EnumCon T.SetRepr)
                               (yIsCl, ycs, y', y_enms, y, EnumCon T.SetRepr)
      pure $ Pair ClosedBoolRepr (E.SubsetExpr x'' y'')
    -- error accordingly if either @x@ or @y@ isn't a set
    (_, T.SetRepr _, _, _) ->
      throwError (TypeMismatchError y (TypeString "a set")
                                      (Just $ SomeType ytp))
    (_,_,_,_) -> throwError (TypeMismatchError x (TypeString "a set")
                                                 (Just $ SomeType xtp))
-- again, mostly the same as the above
tcInferExpr enms env ctx (L _ (S.DiffExpr x y)) = do
  x_enms <- HS.union enms <$> addlEnms env y
  y_enms <- HS.union enms <$> addlEnms env x
  Pair (InfTp xtpc xtp) x' <- tcInferExpr x_enms env ctx x
  Pair (InfTp ytpc ytp) y' <- tcInferExpr y_enms env ctx y
  -- ensure that @x@ and @y@ are both sets
  case (xtpc, xtp, ytpc, ytp) of
    (ClSet xIsCl, T.SetRepr xcs, ClSet yIsCl, T.SetRepr ycs) -> do
      -- ensure that the types of @x@ and @y@ use the same set of enum names
      SameEnumType csc cs x'' y'' <-
        unifyEnumTypes env ctx (xIsCl, xcs, x', x_enms, x, EnumCon T.SetRepr)
                               (yIsCl, ycs, y', y_enms, y, EnumCon T.SetRepr)
      pure $ Pair (InfTp (ClSet csc) (T.SetRepr cs)) (E.DiffExpr x'' y'')
    -- error accordingly if either @x@ or @y@ isn't a set
    (_, T.SetRepr _, _, _) ->
      throwError (TypeMismatchError y (TypeString "a set")
                                      (Just $ SomeType ytp))
    (_,_,_,_) -> throwError (TypeMismatchError x (TypeString "a set")
                                                 (Just $ SomeType xtp))

tcInferExpr enms env ctx (L _ (S.NonEmptyExpr x)) = do
  Pair (InfTp _ xtp) x' <- tcInferExpr enms env ctx x
  case xtp of
    T.SetRepr _ -> pure $ Pair ClosedBoolRepr (E.NonEmptyExpr x')
    _ -> throwError (TypeMismatchError x (TypeString "a set")
                                         (Just $ SomeType xtp))
tcInferExpr enms env ctx (L _ (S.SizeExpr x)) = do
  Pair (InfTp _ xtp) x' <- tcInferExpr enms env ctx x
  case xtp of
    T.SetRepr _ -> pure $ Pair ClosedIntRepr (E.SizeExpr x')
    _ -> throwError (TypeMismatchError x (TypeString "a set")
                                         (Just $ SomeType xtp))

tcInferExpr enms env ctx (L _ (S.AndExpr x y)) =
  tcInferBoolOrSetBinOp enms env ctx x y >>= \case
    Left (x', y') ->
      pure $ Pair ClosedBoolRepr (E.AndExpr x' y')
    Right (SameEnumType csc cs x' y') ->
      pure $ Pair (InfTp (ClSet csc) (T.SetRepr cs)) (E.IntersectExpr x' y')
tcInferExpr enms env ctx (L _ (S.OrExpr x y)) = 
  tcInferBoolOrSetBinOp enms env ctx x y >>= \case
    Left (x', y') ->
      pure $ Pair ClosedBoolRepr (E.OrExpr x' y')
    Right (SameEnumType csc cs x' y') ->
      pure $ Pair (InfTp (ClSet csc) (T.SetRepr cs)) (E.UnionExpr x' y')
tcInferExpr enms env ctx (L _ (S.XorExpr x y)) = 
  tcInferBoolOrSetBinOp enms env ctx x y >>= \case
    Left (x', y') ->
      pure $ Pair ClosedBoolRepr (E.XorExpr x' y')
    Right (SameEnumType csc cs x' y') ->
      pure $ Pair (InfTp (ClSet csc) (T.SetRepr cs)) (E.SymDiffExpr x' y')

tcInferExpr enms env ctx (L _ (S.NotExpr x)) = do
  Pair (InfTp xtpc xtp) x' <- tcInferExpr enms env ctx x
  case (xtpc, xtp) of
    (ClBool, T.BoolRepr) ->
      pure $ Pair ClosedBoolRepr (E.NotExpr x')
    (ClSet xcsc, T.SetRepr xcs) ->
      pure $ Pair (InfTp (ClSet xcsc) (T.SetRepr xcs)) (E.ComplementExpr x')
    _ -> throwError (TypeMismatchError x (TypeString "a boolean or set")
                                         (Just $ SomeType xtp))

tcInferExpr enms env ctx (L _ (S.ImpliesExpr x y)) = do
  x' <- tcExpr enms env ctx T.BoolRepr x
  y' <- tcExpr enms env ctx T.BoolRepr y
  pure $ Pair ClosedBoolRepr (E.ImpliesExpr x' y')
tcInferExpr enms env ctx (L _ (S.IffExpr x y)) = do
  x' <- tcExpr enms env ctx T.BoolRepr x
  y' <- tcExpr enms env ctx T.BoolRepr y
  pure $ Pair ClosedBoolRepr (E.IffExpr x' y')

-- in the 'S.IsInstance' case, get the list of derived constraints of the
-- given type and return the expression which is the conjunction of all of
-- them, with the given expression substituted for @self@ appropriately
tcInferExpr enms env ctx (L _ (S.IsInstanceExpr x tp)) = do
  (Some tp', dcns, enms') <- tcType tp
  x' <- tcExpr (enms `HS.union` enms') env ctx tp' x
  dcns' <- concat <$> mapM (resolveDerivedConstraint env tp') dcns
  let res = if null dcns' then E.LiteralExpr (E.BoolLit True)
                          else foldr1 E.AndExpr (giveSelf x' <$> dcns')
  pure $ Pair ClosedBoolRepr res

tcInferBoolOrSetBinOp :: EnumNameSet
                      -> Assignment T.FunctionTypeRepr env
                      -> Assignment ContextElem ctx
                      -> S.LExpr -> S.LExpr
                      -> TCM2 env (Either ( E.Expr env ctx BoolType
                                          , E.Expr env ctx BoolType )
                                          (SameEnumType env ctx SetType SetType))
tcInferBoolOrSetBinOp enms env ctx x y = do
  x_enms <- HS.union enms <$> addlEnms env y
  y_enms <- HS.union enms <$> addlEnms env x
  Pair (InfTp xtpc xtp) x' <- tcInferExpr x_enms env ctx x
  Pair (InfTp ytpc ytp) y' <- tcInferExpr y_enms env ctx y
  -- ensure that @x@ and @y@ are either both booleans, or both sets
  case (xtpc, xtp, ytpc, ytp) of
    (ClBool, T.BoolRepr, ClBool, T.BoolRepr) -> pure $ Left (x', y')
    (ClSet xIsCl, T.SetRepr xcs, ClSet yIsCl, T.SetRepr ycs) -> Right <$>
      -- ensure that the types of @x@ and @y@ use the same set of enum names
      unifyEnumTypes env ctx (xIsCl, xcs, x', x_enms, x, EnumCon T.SetRepr)
                             (yIsCl, ycs, y', y_enms, y, EnumCon T.SetRepr)
    -- error accordingly if @x@ and @y@ don't have the right types
    (_, T.BoolRepr, _, _) ->
      throwError (TypeMismatchError y (SomeType T.BoolRepr)
                                      (Just $ SomeType ytp))
    (_, _, _, T.BoolRepr) ->
      throwError (TypeMismatchError x (SomeType T.BoolRepr)
                                      (Just $ SomeType xtp))
    (_, T.SetRepr _, _, _) ->
      throwError (TypeMismatchError y (TypeString "a set")
                                      (Just $ SomeType ytp))
    (_, _, _, T.SetRepr _) ->
      throwError (TypeMismatchError x (TypeString "a set")
                                      (Just $ SomeType xtp))
    (_,_,_,_) -> throwError (TypeMismatchError x (TypeString "a boolean or set")
                                                 (Just $ SomeType xtp)) 

-- | Check that the type of an expression is equal to some known type.
tcExpr :: EnumNameSet
       -> Assignment T.FunctionTypeRepr env
       -> Assignment ContextElem ctx
       -> T.TypeRepr tp
       -> S.LExpr
       -> TCM2 env (E.Expr env ctx tp)

tcExpr enms _ _ (T.EnumRepr cs) (L _ (S.EnumLit (L p e))) = do
  unless (e `HS.member` enms) $ emitWarning (EnumNameNotInScope (L p e))
  Some i <- enumElemIndex cs (L p e)
  pure $ E.LiteralExpr (E.EnumLit cs i)
tcExpr _ _ _ tp l@(L _ (S.EnumLit _)) =
  throwError (TypeMismatchError l (SomeType tp)
                                  (Just $ TypeString "an enum"))

tcExpr enms _ _ (T.SetRepr cs) (L _ (S.SetLit es)) = do
  forM_ es $ \(L p e) ->
    unless (e `HS.member` enms) $ emitWarning (EnumNameNotInScope (L p e))
  es' <- mapM (enumElemIndex cs) es
  pure $ E.LiteralExpr (E.SetLit cs es')
tcExpr _ _ _ tp l@(L _ (S.SetLit _)) =
  throwError (TypeMismatchError l (SomeType tp)
                                  (Just $ TypeString "a set"))

-- in the case of an anonymous struct expression, we simply type check its
-- fields against the field types of the given type
tcExpr enms env ctx (T.StructRepr ftps) (L p (S.StructExpr Nothing fvs)) = do
  mfvs' <- tcFields enms env ctx ftps (reverse fvs)
  case mfvs' of
   Just fvs' -> pure $ E.structExpr fvs'
   Nothing -> throwError (StructExprLengthError p (Some ftps) (fst <$> fvs))
-- in the case of a non-anonymous struct expression, we check that the two
-- given types are equal, then do the same thing as in 'tcInferExpr'
tcExpr enms env ctx tp@(T.StructRepr _) x@(L _ (S.StructExpr (Just _) _)) = do
  Pair (InfTp _ tp') x' <- tcInferExpr enms env ctx x
  case testEquality tp tp' of
    Nothing ->
      throwError (TypeMismatchError x (SomeType tp)
                                      (Just $ SomeType tp'))
    Just Refl -> pure x'
tcExpr _ _ _ tp x@(L _ (S.StructExpr _ _)) =
  throwError (TypeMismatchError x (SomeType tp)
                                  (Just $ TypeString "a struct"))

-- since this only gives us more information about one field of @x@'s type
-- relative to the corresponding 'tcInferExpr' case, we first infer the type
-- of @x@ as before, then change the proper field's type to that given and
-- check that @x@ also has this new type
tcExpr enms env ctx tp (L _ (S.FieldExpr x (L p f))) = do
  Pair (InfTp xtpc xtp) _ <- tcInferExpr enms env ctx x
  Some f' <- pure $ someSymbol f
  case (xtpc, xtp) of
    (ClStruct ftpcs, StructRepr ftps) ->
      case getFieldIndex f' (zipWith InfFTp ftpcs ftps) of
        Just (FieldIndex nm _ i) -> do
          Pair ftps' (Flip i') <- pure $ setFieldIndex i (nm, tp) ftps
          x'' <- tcExpr enms env ctx (StructRepr ftps') x
          pure $ E.FieldExpr x'' i'
        Nothing -> throwError (NoSuchFieldError (L p f) x (Some xtp))
    _ -> throwError (TypeMismatchError x (TypeString "a struct")
                                         (Just $ SomeType xtp))

tcExpr enms env ctx tp x = do
  Pair (InfTp tpc tp') x' <- tcInferExpr enms env ctx x
  case (isClosed tpc, testEquality tp tp') of
    -- the cases of 'tcExpr' above should ensure that this first case below
    -- never occurs
    (False, _) -> throwError (TypeInferenceError x)
    (True, Nothing) -> throwError (TypeMismatchError x (SomeType tp)
                                                       (Just $ SomeType tp'))
    (True, Just Refl) -> pure x'

-- | Check that a list of expressions have the respective types of a list of
-- types. Returns 'Nothing' if the function is given a different number of
-- terms and types.
-- NOTE: Currently this assumes that the list of types and the list of
-- fields are in opposite order! We should maybe figure out the right
-- way to do this...
tcExprs :: EnumNameSet
        -> Assignment T.FunctionTypeRepr env
        -> Assignment ContextElem ctx
        -> Assignment T.TypeRepr tps
        -> [(S.LExpr, EnumNameSet)]
        -> TCM2 env (Maybe (Assignment (E.Expr env ctx) tps))
tcExprs _ _ _ Empty [] = pure $ Just Empty
tcExprs enms env ctx (tps :> tp) ((x,enms'):xs) = do
  x' <- tcExpr (enms `HS.union` enms') env ctx tp x
  mxs' <- tcExprs enms env ctx tps xs
  case mxs' of
    Just xs' -> pure $ Just (xs' :> x')
    Nothing -> pure Nothing
tcExprs _ _ _ _ _ = pure Nothing

-- | Returns the index of a given enum name in an assignment of 'SymbolRepr's,
-- erroring if such an index is not found
enumElemIndex :: 1 <= CtxSize cs => Assignment SymbolRepr cs -> LText
              -> TCM2 env (Some (Index cs))
enumElemIndex cs (L p s)
  | Some s' <- someSymbol s, Just i <- elemIndex s' cs = pure (Some i)
  | otherwise = throwError $
      TypeMismatchError (L p (S.EnumLit (L p s)))
                        (SomeType (T.EnumRepr cs)) Nothing

data FieldIndex (ftps :: Ctx (Symbol, T.Type)) (nm :: Symbol) where
  FieldIndex :: SymbolRepr nm -> InferredTypeRepr tp -> Index ftps '(nm, tp)
             -> FieldIndex ftps nm

-- | Given a field name and an assignment of inferred field types, tries to
-- find the field with that name and returns its inferred type and index.
-- Adapted from 'elemIndex'.
getFieldIndex :: SymbolRepr nm
              -> Assignment InferredFieldRepr ftps
              -> Maybe (FieldIndex ftps nm)
getFieldIndex s iftps
  | Left fi <- traverseAndCollect (go s) iftps = Just fi
  | otherwise = Nothing
  where go :: SymbolRepr nm -> Index ftps pr -> InferredFieldRepr pr
           -> Either (FieldIndex ftps nm) ()
        go nm i (InfFTp (ClField tpc) (FieldRepr nm' tp))
          | Just Refl <- testEquality nm nm'
          = Left (FieldIndex nm' (InfTp tpc tp) i)
          | otherwise = Right ()

-- | Given an index into a context of field types, a field, and an assignment
-- of field types, sets the field in the assignment at that index to the field
-- given, and returns the new index to that field.
setFieldIndex :: Index ftps '(nm, tp)
              -> (SymbolRepr nm, T.TypeRepr tp')
              -> Assignment FieldRepr ftps
              -> Pair (Assignment FieldRepr) (Flip Index '(nm, tp'))
setFieldIndex i (nm, tp') ftps = case (viewIndex (size ftps) i, ftps) of
  (IndexViewLast sz, ftps' :> _) ->
    Pair (ftps' :> FieldRepr nm tp') (Flip $ nextIndex sz)
  (IndexViewInit i', ftps' :> ftp)
    | Pair ftps'' (Flip i'') <- setFieldIndex i' (nm, tp') ftps'
    -> Pair (ftps'' :> ftp) (Flip $ skipIndex i'')



-- ** Type inference and checking for field instances

-- | Infer the type of a field expression in a struct expression.
tcInferField :: EnumNameSet
             -> Assignment T.FunctionTypeRepr env 
             -> Assignment ContextElem ctx
             -> (LText, S.LExpr)
             -> TCM2 env (Pair InferredFieldRepr (FieldInst (E.Expr env ctx)))
tcInferField enms env ctx (L _ s, x) = do
  Pair (InfTp tpc tp) x' <- tcInferExpr enms env ctx x
  Some s' <- pure $ someSymbol s
  pure $ Pair (InfFTp (ClField tpc) (FieldRepr s' tp)) (E.FieldInst s' tp x')

-- | Check that a list of fields have the respective types of a list of
-- types. Returns 'Nothing' if the function is given a different number of
-- terms and types. Based on 'tcExprs'.
-- NOTE: Currently this assumes that the list of types and the list of
-- expressions are in opposite order! We should maybe figure out the right
-- way to do this...
tcFields :: EnumNameSet
         -> Assignment T.FunctionTypeRepr env
         -> Assignment ContextElem ctx
         -> Assignment T.FieldRepr ftps
         -> [(LText, S.LExpr)]
         -> TCM2 env (Maybe (Assignment (FieldInst (E.Expr env ctx)) ftps))
tcFields _ _ _ Empty [] = pure $ Just Empty
tcFields enms env ctx (ftps :> FieldRepr s1 tp) ((L p s2, x):fvs) = do
  unless (symbolRepr s1 == s2) $
    throwError (StructExprNameMismatchError (L p s2) (symbolRepr s1))
  x' <- tcExpr enms env ctx tp x
  mfvs' <- tcFields enms env ctx ftps fvs
  case mfvs' of
    Just fvs' -> pure $ Just (fvs' :> E.FieldInst s1 tp x')
    Nothing -> pure Nothing
tcFields _ _ _ _ _ = pure Nothing



-- * Inferred types

-- | When inferring the type of an enum or set literal, we may not have enough
-- information to infer its full type, and want some way to express that the
-- inferred type may be incomplete. We call such types "open", with the
-- antonym "closed" referring to types which are the result of inference,
-- but are known to be complete (e.g. the inferred type of a variable). This
-- datatype captures that distinction - enum and set types may be either open
-- or closed, struct types remember the open-ness of each of their fields, and
-- bool, int, and abstract types are always closed.
data IsClosed tp where
  ClBool   :: IsClosed BoolType
  ClInt    :: IsClosed IntType
  ClEnum   :: Bool -> IsClosed (EnumType cs)
  ClSet    :: Bool -> IsClosed (SetType cs)
  ClStruct :: Assignment IsClosedField ftps -> IsClosed (StructType ftps)
  ClAbs    :: IsClosed (AbsType s)
deriving instance Show (IsClosed tp)
instance ShowF IsClosed

data IsClosedField p where
  ClField  :: IsClosed tp -> IsClosedField '(nm, tp)
deriving instance Show (IsClosedField p)
instance ShowF IsClosedField

-- | An 'InferredTypeRepr' is a 'TypeRepr' along with whether the type is open
-- or closed ('IsClosed').
data InferredTypeRepr tp where
  InfTp :: IsClosed tp -> T.TypeRepr tp -> InferredTypeRepr tp
deriving instance Show (InferredTypeRepr tp)
instance ShowF InferredTypeRepr

-- Some useful pattern synonyms, which we unfortunately we have to give
-- type signatures for (otherwise GHC will generate a lot of warnings)
pattern ClosedBoolRepr :: () => tp ~ BoolType => InferredTypeRepr tp
pattern ClosedIntRepr  :: () => tp ~ IntType  => InferredTypeRepr tp
pattern ClosedEnumRepr :: () => (1 <= CtxSize cs, tp ~ EnumType cs)
                       => Assignment SymbolRepr cs
                       -> InferredTypeRepr tp
pattern OpenEnumRepr   :: () => (1 <= CtxSize cs, tp ~ EnumType cs)
                       => Assignment SymbolRepr cs
                       -> InferredTypeRepr tp
pattern ClosedSetRepr  :: () => (1 <= CtxSize cs, tp ~ SetType cs )
                       => Assignment SymbolRepr cs
                       -> InferredTypeRepr tp
pattern OpenSetRepr    :: () => (1 <= CtxSize cs, tp ~ SetType cs )
                       => Assignment SymbolRepr cs
                       -> InferredTypeRepr tp
pattern ClosedAbsRepr  :: () => tp ~ AbsType s 
                       => SymbolRepr s -> InferredTypeRepr tp
pattern ClosedBoolRepr    = InfTp ClBool T.BoolRepr
pattern ClosedIntRepr     = InfTp ClInt  T.IntRepr
pattern ClosedEnumRepr cs = InfTp (ClEnum True ) (T.EnumRepr cs)
pattern OpenEnumRepr   cs = InfTp (ClEnum False) (T.EnumRepr cs)
pattern ClosedSetRepr  cs = InfTp (ClSet  True ) (T.SetRepr  cs)
pattern OpenSetRepr    cs = InfTp (ClSet  False) (T.SetRepr  cs)
pattern ClosedAbsRepr  s  = InfTp ClAbs (T.AbsRepr s)

-- | The closed 'InferredTypeRepr' for any type
closed :: TypeRepr tp -> InferredTypeRepr tp
closed BoolRepr          = ClosedBoolRepr
closed IntRepr           = ClosedIntRepr
closed (EnumRepr cs)     = ClosedEnumRepr cs
closed (SetRepr  cs)     = ClosedSetRepr  cs
closed (AbsRepr  s)      = ClosedAbsRepr  s
closed (StructRepr ftps) = InfTp (ClStruct (fmapFC closedField ftps))
                                 (StructRepr ftps)
  where closedField :: FieldRepr p -> IsClosedField p
        closedField (FieldRepr _ tp) | InfTp tpc _ <- closed tp = ClField tpc

-- | Returns true iff the given type is closed, where struct types are only
-- considered closed if all of their fields are.
isClosed :: IsClosed tp -> Bool
isClosed ClBool          = True
isClosed ClInt           = True
isClosed (ClEnum b)      = b
isClosed (ClSet  b)      = b
isClosed (ClStruct ftps) = and (toListFC (\(ClField tpc) -> isClosed tpc) ftps)
isClosed ClAbs           = True

data InferredFieldRepr p where
  InfFTp :: IsClosedField p -> T.FieldRepr p -> InferredFieldRepr p
deriving instance Show (InferredFieldRepr p)
instance ShowF InferredFieldRepr

-- | A nicer way to construct things of type
-- @'InferredTypeRepr' ('StructType' ftps)@
infStructRepr :: Assignment InferredFieldRepr ftps
              -> InferredTypeRepr (StructType ftps)
infStructRepr iftps
  | (ftpcs, ftps) <- unzipInfTps iftps
  = InfTp (ClStruct ftpcs) (StructRepr ftps)
  where unzipInfTps :: Assignment InferredFieldRepr ftps
                    -> ( Assignment IsClosedField ftps
                       , Assignment FieldRepr ftps )
        unzipInfTps Empty = (Empty, Empty)
        unzipInfTps (itps :> InfFTp tpc tp)
          | (tpcs, tps) <- unzipInfTps itps = (tpcs :> tpc, tps :> tp)

-- ** Unification of inferred types

-- | Two expressions of the same inferred type, existentially quantified
data SameExprType env ctx where
  SameExprType :: NonAbstract tp => InferredTypeRepr tp
               -> E.Expr env ctx tp -> E.Expr env ctx tp
               -> SameExprType env ctx

unifyExprTypes :: (NonAbstract tp1, NonAbstract tp2)
               => Assignment T.FunctionTypeRepr env
               -> Assignment ContextElem ctx
               -> (InferredTypeRepr tp1, E.Expr env ctx tp1, EnumNameSet, S.LExpr)
               -> (InferredTypeRepr tp2, E.Expr env ctx tp2, EnumNameSet, S.LExpr)
               -> TCM2 env (SameExprType env ctx)
unifyExprTypes env ctx (xitp@(InfTp xtpc xtp), x', x_enms, x)
                       (yitp@(InfTp ytpc ytp), y', y_enms, y) =
  case (testEquality xtp ytp, isClosed xtpc, isClosed ytpc) of
    (Just Refl, _, _) -> pure $ SameExprType xitp x' y'
    (_, True, False) -> do
      y'' <- tcExpr y_enms env ctx xtp y
      pure $ SameExprType xitp x' y''
    (_, False, True) -> do
      x'' <- tcExpr x_enms env ctx ytp x
      pure $ SameExprType yitp x'' y'
    (_, False, False)
      | Just (Pair uni_itp@(InfTp _ uni_tp) IsNonAbs) <- unifyTypes xitp yitp
      -> do { x'' <- tcExpr x_enms env ctx uni_tp x
            ; y'' <- tcExpr y_enms env ctx uni_tp y
            ; pure $ SameExprType uni_itp x'' y''
            } `catchError` (const $ throwError uni_error)
            -- this ^ error case should never occur, but GHC doesn't know that
    _ -> throwError uni_error
    where uni_error = TypeUnificationError x (SomeType xtp) y (SomeType ytp)

-- | A 'TypeRepr' constructor which involves enum names, i.e. 'EnumRepr' or
-- 'SetRepr'
newtype EnumCon f = EnumCon (forall cs. 1 <= CtxSize cs =>
                               Assignment SymbolRepr cs -> TypeRepr (f cs))

-- | Two expressions with types involving the same set of enum names,
-- existentially quantified
data SameEnumType env ctx f1 f2 where
  SameEnumType :: 1 <= CtxSize cs => Bool -> Assignment SymbolRepr cs
               -> E.Expr env ctx (f1 cs)
               -> E.Expr env ctx (f2 cs)
               -> SameEnumType env ctx f1 f2

unifyEnumTypes :: (1 <= CtxSize cs1, 1 <= CtxSize cs2)
               => Assignment T.FunctionTypeRepr env
               -> Assignment ContextElem ctx
               -> ( Bool, Assignment SymbolRepr cs1
                  , E.Expr env ctx (f1 cs1), EnumNameSet, S.LExpr
                  , EnumCon f1 )
               -> ( Bool, Assignment SymbolRepr cs2
                  , E.Expr env ctx (f2 cs2), EnumNameSet, S.LExpr
                  , EnumCon f2 )
               -> TCM2 env (SameEnumType env ctx f1 f2)
unifyEnumTypes env ctx (xIsCl, xcs, x', x_enms, x, EnumCon xf)
                       (yIsCl, ycs, y', y_enms, y, EnumCon yf) =
  case (testEquality xcs ycs, xIsCl, yIsCl) of
    (Just Refl, _, _) -> pure $ SameEnumType (xIsCl || yIsCl) xcs x' y'
    (_, True, False) -> do
      y'' <- tcExpr y_enms env ctx (yf xcs) y
      pure $ SameEnumType True xcs x' y''
    (_, False, True) -> do
      x'' <- tcExpr x_enms env ctx (xf ycs) x
      pure $ SameEnumType True ycs x'' y'
    (_, False, False)
      | Pair uni_cs NonEmpty <- unifyEnumNames xcs ycs
      -> do { x'' <- tcExpr x_enms env ctx (xf uni_cs) x
            ; y'' <- tcExpr y_enms env ctx (yf uni_cs) y
            ; pure $ SameEnumType False uni_cs x'' y''
            } `catchError` (const $ throwError uni_error)
    _ -> throwError uni_error
  where uni_error = EnumSetUnificationError x (SomeType (xf xcs))
                                            y (SomeType (yf xcs))

-- | Given the inferred types of two terms, try to produce a single inferred
-- type which is a valid for both terms, using whether the given types are
-- open or closed.
unifyTypes :: (NonAbstract tp1, NonAbstract tp2)
           => InferredTypeRepr tp1
           -> InferredTypeRepr tp2
           -> Maybe (Pair InferredTypeRepr IsNonAbstract)

unifyTypes ClosedBoolRepr ClosedBoolRepr = pure $ Pair ClosedBoolRepr IsNonAbs
unifyTypes ClosedIntRepr  ClosedIntRepr  = pure $ Pair ClosedIntRepr  IsNonAbs

unifyTypes (ClosedEnumRepr cs1) (ClosedEnumRepr cs2)
  | Just Refl <- testEquality cs1 cs2
  = pure $ Pair (ClosedEnumRepr cs1) IsNonAbs
unifyTypes (ClosedEnumRepr cs1) (OpenEnumRepr cs2)
  | [] <- (toEnumNameList cs2) \\ (toEnumNameList cs1)
  = pure $ Pair (ClosedEnumRepr cs1) IsNonAbs
unifyTypes (OpenEnumRepr cs1) (ClosedEnumRepr cs2)
  | [] <- (toEnumNameList cs1) \\ (toEnumNameList cs2)
  = pure $ Pair (ClosedEnumRepr cs2) IsNonAbs
unifyTypes (OpenEnumRepr cs1) (OpenEnumRepr cs2)
  | Pair cs NonEmpty <- unifyEnumNames cs1 cs2
  = pure $ Pair (OpenEnumRepr cs) IsNonAbs

unifyTypes (ClosedSetRepr cs1) (ClosedSetRepr cs2)
  | Just Refl <- testEquality cs1 cs2
  = pure $ Pair (ClosedSetRepr cs1) IsNonAbs
unifyTypes (ClosedSetRepr cs1) (OpenSetRepr cs2)
  | [] <- (toEnumNameList cs2) \\ (toEnumNameList cs1)
  = pure $ Pair (ClosedSetRepr cs1) IsNonAbs
unifyTypes (OpenSetRepr cs1) (ClosedSetRepr cs2)
  | [] <- (toEnumNameList cs1) \\ (toEnumNameList cs2)
  = pure $ Pair (ClosedSetRepr cs2) IsNonAbs
unifyTypes (OpenSetRepr cs1) (OpenSetRepr cs2)
  | Pair cs NonEmpty <- unifyEnumNames cs1 cs2
  = pure $ Pair (OpenSetRepr cs) IsNonAbs

unifyTypes (InfTp (ClStruct ftpcs1) (T.StructRepr ftps1))
           (InfTp (ClStruct ftpcs2) (T.StructRepr ftps2)) = do
  Pair ftps IsNonAbs <- unifyFields (zipWith InfFTp ftpcs1 ftps1)
                                    (zipWith InfFTp ftpcs2 ftps2)
  pure $ Pair (infStructRepr ftps) IsNonAbs

unifyTypes _ _ = Nothing

-- | Given the inferred types of two fields, try to produce a single inferred
-- field type which is a valid for both fields, using the field names and
-- whether the given types are open or closed.
unifyFields :: (NonAbstract ftps1, NonAbstract ftps2)
            => Assignment InferredFieldRepr ftps1
            -> Assignment InferredFieldRepr ftps2
            -> Maybe (Pair (Assignment InferredFieldRepr) IsNonAbstract)
unifyFields Empty Empty = pure $ Pair Empty IsNonAbs
unifyFields (ftps1 :> InfFTp (ClField tpc1) (FieldRepr nm1 tp1))
            (ftps2 :> InfFTp (ClField tpc2) (FieldRepr nm2 tp2)) = do
  Refl                         <- testEquality nm1 nm2
  Pair (InfTp tpc tp) IsNonAbs <- unifyTypes (InfTp tpc1 tp1) (InfTp tpc2 tp2)
  Pair ftps IsNonAbs           <- unifyFields ftps1 ftps2
  pure $ Pair (ftps :> InfFTp (ClField tpc) (FieldRepr nm1 tp)) IsNonAbs
unifyFields _ _ = Nothing

-- | A witness that the given context of symbols is nonempty
data NonEmpty (cs :: Ctx Symbol) where
  NonEmpty :: 1 <= CtxSize cs => NonEmpty cs

-- | The union of two nonempty 'Assignment SymbolRepr', using 'toEnumNameList'
-- and 'fromEnumNameList'
unifyEnumNames :: (1 <= CtxSize cs1, 1 <= CtxSize cs2)
               => Assignment SymbolRepr cs1 -> Assignment SymbolRepr cs2
               -> Pair (Assignment SymbolRepr) NonEmpty
unifyEnumNames cs1 cs2 = 
  fromEnumNameList ((toEnumNameList cs1) `union` (toEnumNameList cs2))

-- | Given a list of enum names, return a non-empty assignment of symbols -
-- where if the given list is empty, return an assignment consisting of
-- an empty symbol (`knownSymbol @""``).
-- This is a terrible hack, only necessary because 'SetRepr' demands that the
-- given list of names is nonempty but we want to be able to infer a type of
-- the empty set with no other information.
fromEnumNameList :: [Some SymbolRepr] -> Pair (Assignment SymbolRepr) NonEmpty
fromEnumNameList cs_list | Some cs <- fromList cs_list =
  case decideLeq (knownNat @1) (ctxSizeNat (size cs)) of
    Left LeqProof -> Pair cs NonEmpty
    Right _ -> Pair (Empty :> knownSymbol @"") NonEmpty

-- | The inverse of 'fromEnumNameList' - thus, in particular, the resulting
-- list has all empty symbols filtered out
toEnumNameList :: Assignment SymbolRepr cs -> [Some SymbolRepr]
toEnumNameList = filter (\s -> s /= Some (knownSymbol @"")) . toListFC Some

-- | Like `toEnumNameList`, but instead returns the index of each symbol in the
-- given assignment instead of the symbol itself.
enumSetIndices :: Assignment SymbolRepr cs -> [Some (Index cs)]
enumSetIndices = catMaybes . toListWithIndex go
  where go i s | Some s == Some (knownSymbol @"") = Nothing
               | otherwise = Just (Some i)
