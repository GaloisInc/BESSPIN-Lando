{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE StandaloneDeriving #-}

{-|
Module      : Lobot.TypeCheck.Monad
Description : The monad used during LOBOT type checking.
Copyright   : (c) Matthew Yacavone, 2020
License     : BSD3
Maintainer  : myac@galois.com
Stability   : experimental
Portability : POSIX

This module defines the monad used while type checking the Lobot AST.

-}

module Lobot.TypeCheck.Monad 
  ( TCM
  , WithWarnings
  , NamedThing(..)
  , evalTCM
  , emitWarning
  , ensureUnique
  -- ** Type errors and warnings
  , TypeError(..)
  , TypeWarning(..)
  , SomeTypeOrString(..)
  , ppTypeError
  , ppTypeWarning
  , ppSomeTypeOrString
  ) where

import qualified Data.HashMap.Strict as H
import qualified Data.HashSet as HS
import qualified Text.PrettyPrint as PP
import qualified Data.Set as Set
import Data.Set (Set)

import Data.Text (Text)
import Data.List.NonEmpty (NonEmpty(..))
import Data.Functor.Const
import Control.Monad.State
import Control.Monad.Writer
import Control.Monad.Except
-- import Data.Functor.Const
import Data.Parameterized.BoolRepr
import Data.Parameterized.Some
import Data.Parameterized.Context
import Prelude hiding (zipWith, unzip)

import Lobot.Lexer (AlexPosn, errorPrefix)
import Lobot.Syntax as S
import Lobot.Types as T
import Lobot.Pretty as P
import Lobot.Syntax.Pretty as S
import Lobot.TypeCheck.IDecls (DerivedConstraint, getDerivedConstraintKinds, EnumNameSet)


-- | Either a named kind or function, used in the state of 'TCM'. Note that
-- this type is parameterized by a type of constraints, as this type varies
-- between the two passes of type checking.
-- 
-- For kinds, this holds the kind's type, its list of constraints, a 'Bool' of
-- whether this list is nonempty, and the set of enum names which this kind
-- has in scope. For functions, this holds the function's argument types,
-- return type, argument type constraints, return type constraint, set of enum
-- names which each argument type should bring into scope, and set of enum
-- names which the return type should bring into scope.
data NamedThing cns where
  NamedKind     :: T.TypeRepr tp
                -> cns (EmptyCtx ::> tp) -> Bool
                -> EnumNameSet
                -> NamedThing cns
  NamedFunction :: Assignment T.TypeRepr args -> T.TypeRepr ret
                -> cns args                   -> cns (EmptyCtx ::> ret)
                -> [EnumNameSet]              -> EnumNameSet
                -> Assignment (Const Text) args
                -> NamedThing cns


type WithWarnings a = WriterT (Set TypeWarning) a

-- | The monad used in both passes of type checking, with the type argument
-- @cns@ being what varies between passes. This monad contains a state which
-- is a map from 'Text' to 'NamedThing's, accumulates 'TypeWarning's, and
-- has error type 'err'.
newtype TCM cns err a =
  TCM { unTCM :: StateT (H.HashMap Text (NamedThing cns))
                        (WithWarnings (Either err)) a }
  deriving ( Functor
           , Applicative
           , Monad
           , MonadState (H.HashMap Text (NamedThing cns))
           , MonadWriter (Set TypeWarning) )

deriving instance MonadError err (TCM cns err)

-- | Evaluate a 'TCM' computation
evalTCM :: TCM cns err a -> WithWarnings (Either err) a
evalTCM m = evalStateT (unTCM m) H.empty

-- | Emit a single warning in a 'TCM' computation
emitWarning :: TypeWarning -> TCM cns err ()
emitWarning = tell . Set.singleton

-- | Throws the given error if the names associated to given list, as
-- determined by the given function, are not unique.
ensureUnique :: (a -> Text) -> [a] -> (a -> err) -> TCM cns err ()
ensureUnique f xs err =
  foldM_ (\xset x -> if (f x) `HS.member` xset
                     then throwError (err x)
                     else pure $ HS.insert (f x) xset) HS.empty xs


-- | All type errors that can be generated by the typechecker.
data TypeError = TypeMismatchError S.LExpr SomeTypeOrString (Maybe SomeTypeOrString)
                 -- ^ argument order: expr, expected type, actual type
               | AbstractEqualityError S.LExpr SomeTypeOrString
               | TypeUnificationError S.LExpr SomeTypeOrString S.LExpr SomeTypeOrString
               | EnumSetUnificationError S.LExpr SomeTypeOrString S.LExpr SomeTypeOrString
               | TypeSynonymConstrainedError S.LText DerivedConstraint
               | TypeInferenceError S.LExpr
               | DuplicateEnumNameError S.LType Text
               | EmptyEnumOrSetError S.LType
               | SubsetTypeError S.LType
               | KindUnionMismatchError LText (Some T.TypeRepr) (Some T.TypeRepr)
               -- ^ argument order: kind name, expected type, actual type
               | NoSuchFieldError LText S.LExpr (Some T.TypeRepr)
               | StructExprTypeError S.LType
               | StructExprNameMismatchError LText Text
               | StructExprLengthError AlexPosn (Some (Assignment FieldRepr)) [LText]
               | StructExprAbstractTypeError AlexPosn (Some (Assignment FieldRepr))
               | KindNameNotInScope LText
               | FunctionNameNotInScope LText
               | FieldNameNotInScope LText
               | OtherNameNotInScope LText
               | KindNameAlreadyDefined LText
               | FunctionNameAlreadyDefined LText
               | FieldNameAlreadyDefined LText
               | FunctionArgLengthError LText (Some FunctionTypeRepr) [S.LExpr]
               | UnexpectedSelfError AlexPosn
               | InternalError AlexPosn Text
               deriving Show

-- | All warnings that can be generated by the typechecker.
data TypeWarning = EnumNameNotInScope LText
                 | KindHasNoConstraints LText
                 deriving (Eq, Ord)

ppTypeError :: FilePath -> TypeError -> PP.Doc
ppTypeError fp (TypeMismatchError (L p x) exp_tp Nothing)
  | SomeType tp <- exp_tp, Nothing <- isNonAbstract tp
  = PP.text (errorPrefix fp p)
    PP.<+> PP.text "Cannot construct a term of abstract type:"
    PP.<+> PP.nest 6 (ppSomeTypeOrString exp_tp)
    PP.$$  PP.nest 2 (PP.text "Type mismatch on expression:" PP.<+> S.ppExpr x)
  | otherwise
  = PP.text (errorPrefix fp p)
    PP.<+> PP.text "Type mismatch on expression:" PP.<+> S.ppExpr x
    PP.$$ PP.nest 2 (PP.text "Expected type:") PP.<+> PP.nest 6 (ppSomeTypeOrString exp_tp)
ppTypeError fp (TypeMismatchError x exp_tp (Just act_tp)) =
  ppTypeError fp (TypeMismatchError x exp_tp Nothing)
  PP.$$ PP.nest 2 (PP.text "  Actual type:") PP.<+> PP.nest 6 (ppSomeTypeOrString act_tp)
ppTypeError fp (AbstractEqualityError (L p x) tp) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Equality comparison on abstract type:" PP.<+> ppSomeTypeOrString tp
  PP.$$ PP.nest 2 (PP.text "In expression:" PP.<+> S.ppExpr x)
ppTypeError fp (TypeUnificationError (L p x) xtp (L _ y) ytp) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Could not unify the types of the following expressions:"
  PP.$$  PP.nest 2 (PP.text "-" PP.<+> S.ppExpr x)
  PP.<+> PP.nest 6 (PP.text ":" PP.<+> ppSomeTypeOrString xtp)
  PP.$$  PP.nest 2 (PP.text "-" PP.<+> S.ppExpr y)
  PP.<+> PP.nest 6 (PP.text ":" PP.<+> ppSomeTypeOrString ytp)
ppTypeError fp (EnumSetUnificationError (L p x) xtp (L _ y) ytp) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Could not unify the name sets in the types of the following expressions:"
  PP.$$  PP.nest 2 (PP.text "-" PP.<+> S.ppExpr x)
  PP.<+> PP.nest 6 (PP.text ":" PP.<+> ppSomeTypeOrString xtp)
  PP.$$  PP.nest 2 (PP.text "-" PP.<+> S.ppExpr y)
  PP.<+> PP.nest 6 (PP.text ":" PP.<+> ppSomeTypeOrString ytp)
ppTypeError fp (TypeSynonymConstrainedError (L _ t) dcn)
  | (L p k) :| _ <- getDerivedConstraintKinds dcn =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "The constrained kind" PP.<+> ppQText k
  PP.<+> PP.text "appears in the definition of the type synonym" PP.<+> ppQText t
ppTypeError fp (TypeInferenceError (L p x)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Could not infer the type of expression:" PP.<+> S.ppExpr x
ppTypeError fp (DuplicateEnumNameError (L p tp) nm) =
  PP.text (errorPrefix fp p)
  PP.<+> ppQText nm PP.<+> PP.text "appears more than once in the enum or set:" PP.<+> S.ppType tp
ppTypeError fp (EmptyEnumOrSetError (L p tp)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Empty enum or set:" PP.<+> S.ppType tp
ppTypeError fp (SubsetTypeError (L p tp)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Cannot take a subset of type:" PP.<+> S.ppType tp 
  PP.$$ PP.nest 2 (PP.text "Only subsets of unconstrained enum types are currently permitted.")
ppTypeError fp (KindUnionMismatchError (L p k) (Some exp_tp) (Some act_tp)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "In a kind union, type mismatch on kind name:" PP.<+> S.ppText k
  PP.$$ PP.nest 2 (PP.text "Expected type:") PP.<+> PP.nest 6 (ppTypeRepr exp_tp)
  PP.$$ PP.nest 2 (PP.text "  Actual type:") PP.<+> PP.nest 6 (ppTypeRepr act_tp)
ppTypeError fp (NoSuchFieldError (L p f) (L _ x) (Some tp)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "No such field" PP.<+> ppQText f PP.<+> PP.text "of expression:"
  PP.$$ PP.nest 2 (S.ppExpr x PP.<+> PP.text ":" PP.<+> ppTypeRepr tp)
ppTypeError fp (StructExprTypeError (L p tp)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Type given for a struct instance is not an unconstrained struct type:" PP.<+> S.ppType tp
ppTypeError fp (StructExprNameMismatchError (L p s1) s2) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Field in struct instance" PP.<+> ppQText s1
  PP.<+> PP.text "does not match the exepcted field" PP.<+> ppQText s2
ppTypeError fp (StructExprLengthError p (Some ftps) fvs) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Struct literal should have" PP.<+> PP.int (sizeInt . size $ ftps)
  PP.<+> PP.text "fields, but has" PP.<+> PP.int (length fvs)
ppTypeError fp (StructExprAbstractTypeError p _) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Cannot construct a literal of a struct type containg an abstract type."
ppTypeError fp (KindNameNotInScope (L p k)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Kind name" PP.<+> ppQText k PP.<+> PP.text "not in scope."
ppTypeError fp (FunctionNameNotInScope (L p fn)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Function name" PP.<+> ppQText fn PP.<+> PP.text "not in scope."
ppTypeError fp (FieldNameNotInScope (L p f)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Field name" PP.<+> ppQText f PP.<+> PP.text "not in scope."
ppTypeError fp (OtherNameNotInScope (L p nm)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Identifier" PP.<+> ppQText nm PP.<+> PP.text "not in scope."
ppTypeError fp (KindNameAlreadyDefined (L p k)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "A kind or type with name" PP.<+> ppQText k PP.<+> PP.text "is already defined."
ppTypeError fp (FunctionNameAlreadyDefined (L p fn)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "A function with name" PP.<+> ppQText fn PP.<+> PP.text "is already defined."
ppTypeError fp (FieldNameAlreadyDefined (L p f)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "A field with name" PP.<+> ppQText f PP.<+> PP.text "is already in scope."
ppTypeError fp (FunctionArgLengthError (L p fn) (Some (FunctionTypeRepr{..})) args) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Function" PP.<+> ppQText fn
  PP.<+> PP.text "expects" PP.<+> PP.int (sizeInt . size $ functionArgTypes)
  PP.<+> PP.text "arguments, but was given" PP.<+> PP.int (length args)
ppTypeError fp (UnexpectedSelfError p) =
  PP.text (errorPrefix fp p) PP.<+> PP.text "Unexpected 'self'."
ppTypeError fp (InternalError p str) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Internal error!" PP.$$ PP.nest 2 (S.ppText str)

ppQText :: Text -> PP.Doc
ppQText = PP.quotes . S.ppText

ppTypeWarning :: FilePath -> TypeWarning -> PP.Doc
ppTypeWarning fp (EnumNameNotInScope (L p fn)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Warning: Enum name" PP.<+> S.ppText fn PP.<+> PP.text "not in scope."
ppTypeWarning fp (KindHasNoConstraints (L p k)) =
  PP.text (errorPrefix fp p)
  PP.<+> PP.text "Warning: Kind" PP.<+> ppQText k
  PP.<+> PP.text "is unconstrained, consider using a type synonym."

data SomeTypeOrString :: * where
  SomeType   :: T.TypeRepr tp -> SomeTypeOrString
  TypeString :: Text -> SomeTypeOrString
deriving instance Show SomeTypeOrString

ppSomeTypeOrString :: SomeTypeOrString -> PP.Doc
ppSomeTypeOrString (SomeType tp) = ppTypeRepr tp
ppSomeTypeOrString (TypeString s) = S.ppText s
