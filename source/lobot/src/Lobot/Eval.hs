{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE StandaloneDeriving #-}

{-|
Module      : Lobot.Eval
Description : Evaluation for Lobot expressions.
Copyright   : (c) Matthew Yacavone, Ben Selfridge, 2020
License     : BSD3
Maintainer  : benselfridge@galois.com
Stability   : experimental
Portability : POSIX

This modules defines evaluation for the Lobot expression data type.
-}
module Lobot.Eval
  ( -- * Function implementation
    FunctionImpl(..)
  , fnImplType
    -- * Evaluation
  , evalExpr
  , EvalResult(..)
  , getFailingConstraints
  , callFn
  , callFnLazy
    -- ** The 'EvalM' monad
  , EvalM
  , runEvalM
  , FunctionCallCache
  , FunctionCallResult(..)
  , askImpls
  , askLits
  , askCache
  , tellResult
  , liftST
  ) where

import Lobot.Expr
import Lobot.Kind
import Lobot.Pretty
import Lobot.Types
import Lobot.Utils

import qualified Text.PrettyPrint as PP
import qualified Data.Text        as T

import Control.Monad.Reader
import Control.Monad.ST
import Data.Parameterized.HashTable
import System.IO.Unsafe (unsafeInterleaveIO)
import UnliftIO (MonadUnliftIO(..), withRunInIO)
import UnliftIO.IORef (IORef, newIORef, modifyIORef, readIORef)
import Data.Functor.Const
import Data.Bits (xor)
import Data.List (find, intersect, union, (\\))
import Data.Maybe (isNothing, catMaybes)
import Data.Parameterized.Classes
import Data.Parameterized.Context hiding (null)
import Data.Parameterized.Some
import Data.Parameterized.TraversableFC
import System.Exit
import Prelude hiding (lookup)

-- | Implementation of a function.
data FunctionImpl m env fntp where
  FunctionImpl :: { fnImplCFun :: ConstrainedFunction env (FunType nm args ret)
                  , fnImplRun :: Assignment Literal args -> m (Literal ret, String)
                  } -> FunctionImpl m env (FunType nm args ret)

fnImplType :: FunctionImpl m env fntp -> FunctionTypeRepr fntp
fnImplType (FunctionImpl cfun _) = cfunType cfun

-- | An 'STRef' which stores function calls and their literal results.
-- Although this is not captured in the type, we assume that the argument
-- expressions in each 'FunctionCall' key are "reduced" (i.e. are the results
-- of calling 'evalExpr').
type FunctionCallCache env ctx =
  HashTable RealWorld (FunctionCall env ctx) Literal

-- | The result of a function call on a particular set of argument expressions,
-- whose return type is not abstract. This is used for refining the solver's
-- model of the function to improve its search during instance generation.
data FunctionCallResult env ctx where
  FunctionCallResult :: NonAbstract ret
                     => Index env (FunType nm args ret)
                     -- ^ Index of the called function
                     -> Assignment (Expr env ctx) args
                     -- ^ Argument expressions
                     -> Literal ret
                     -- ^ Literal value of result
                     -> String
                     -- ^ Any console output generated by the function
                     -> FunctionCallResult env ctx

deriving instance Show (FunctionCallResult env ctx)

-- | Expression evaluation monad - a monad transformer which has an environment
-- of function implementations, an assignment of literals for the given
-- context, and a 'FunctionCallCache' reference, and accumulates a list of
-- 'FunctionCallResult's, which is indended to include all function calls
-- which were added to the cache during evaluation.
newtype EvalM env ctx m a =
  EvalM { unEvalM :: ReaderT ( Assignment (FunctionImpl m env) env
                             , Assignment Literal ctx
                             , FunctionCallCache env ctx
                             , IORef [FunctionCallResult env ctx] ) m a }
  deriving ( Functor
           , Applicative
           , Monad
           , MonadIO
           , MonadFail
           )

deriving instance MonadUnliftIO m => MonadUnliftIO (EvalM env ctx m)

instance MonadTrans (EvalM env ctx) where
  lift = EvalM . lift

askImpls :: Monad m => EvalM env ctx m (Assignment (FunctionImpl m env) env)
askImpls = EvalM $ reader (\(fns,_,_,_) -> fns)

askLits :: Monad m => EvalM env ctx m (Assignment Literal ctx)
askLits = EvalM $ reader (\(_,ls,_,_) -> ls)

askCache :: Monad m => EvalM env ctx m (FunctionCallCache env ctx)
askCache = EvalM $ reader (\(_,_,cache,_) -> cache)

tellResult :: MonadIO m => FunctionCallResult env ctx -> EvalM env ctx m ()
tellResult res = do
  ref <- EvalM $ reader (\(_,_,_,ref) -> ref)
  modifyIORef ref (res:)

liftST :: MonadIO m => ST RealWorld a -> m a
liftST = liftIO . stToIO

-- | Unwrap an 'EvalM' computation, collecting both the result of the evaluation
-- and a list of all of the 'FunctionCallResult's computed as the result of
-- calling concrete functions.
runEvalM :: MonadIO m
         => Assignment (FunctionImpl m env) env
         -> Assignment Literal ctx
         -> FunctionCallCache env ctx
         -> EvalM env ctx m a -> m (a, [FunctionCallResult env ctx])
runEvalM fns ls cache k = do
  ref <- newIORef []
  a <- runReaderT (unEvalM k) (fns, ls, cache, ref)
  rs <- a `seq` readIORef ref
  pure (a, rs)

-- | Call a given function using its implementation and ensure that all of its
-- return type constraints hold using 'getFailingConstraints'.
callFn :: (MonadUnliftIO m, MonadFail m)
       => Index env (FunType nm args ret)
       -> Assignment Literal args
       -> Assignment (Expr env ctx) args
       -> EvalM env ctx m (Literal ret, String)
callFn fi argLits argEs = do
  fns <- askImpls
  let fn = fns ! fi
  (l, outp) <- lift $ fnImplRun fn argLits
  -- when checking that this function's return constraints hold, we
  -- temporarily add this call to the cache, regardless of whether it has
  -- abstract return type or not
  cache <- askCache
  liftST $ insert cache (FunctionCall fi argEs) l
  let cns = fmap (giveSelf (ApplyExpr fi argEs))
                 (cfunRetConstraints (fnImplCFun fn))
  fcns <- getFailingConstraints cns
  liftST $ delete cache (FunctionCall fi argEs)
  when (not (null fcns)) $ askLits >>= \ls -> liftIO $ do
    let env = fmapFC fnImplType fns
        ctx = fmapFC literalType ls
        nms = fmapFC (Const . T.pack . show . ppLiteral) ls
    putStrLn $ "\n[Plugin error] The following call:"
    print . PP.nest 2 $
      ppExpr env ctx nms (ApplyExpr fi argEs) PP.<+> PP.equals PP.<+> ppLiteral l
    putStrLn $ "did not satisfy its return constraint(s):"
    forM_ fcns (\c -> print . PP.nest 2 $ ppExpr env ctx nms c)
    exitFailure
  pure (l, outp)

-- | Using some lazy IO magic, a version of 'callFn' which only performs
-- any inner IO actions when its resulting value is demanded.
callFnLazy :: (MonadUnliftIO m, MonadFail m)
           => Index env (FunType nm args ret)
           -> Assignment Literal args
           -> Assignment (Expr env ctx) args
           -> EvalM env ctx m (Literal ret, String)
callFnLazy fi argsLits argEs = 
  withRunInIO $ \run -> unsafeInterleaveIO $ run (callFn fi argsLits argEs)

data EvalResult env ctx tp =
  EvalResult { evalResultLit :: Literal tp
             , evalResultExpr :: Expr env ctx tp
             }

litEvalResult :: NonAbstract tp
              => Literal tp
              -> EvalResult env ctx tp
litEvalResult l = EvalResult l (LiteralExpr l)

-- | Evaluate an expression.
--
-- When we evaluate an expression, there are two things we might want back. The
-- first and most obvious is a 'Literal', i.e. the literal result of evaluating
-- the expression. The second is another 'Expr', consisting of what the
-- expression becomes after all non-abstract subexpressions have been evaluated.
--
-- If the expression's type is non-abstract, we simply return the literal as a
-- 'LiteralExpr'. If it is abstract, we reconstruct the original expression
-- after all sub-expressions have been simplified in this manner.
evalExpr :: (MonadUnliftIO m, MonadFail m)
         => Expr env ctx tp
         -> EvalM env ctx m (EvalResult env ctx tp)
evalExpr e = case e of
  LiteralExpr l -> pure $ litEvalResult l
  StructExpr fls -> do
    evalFls <- traverseFC evalField fls
    let flLits = fmapFC evalResultFieldLit evalFls
        flEs = fmapFC evalResultFieldExpr evalFls
    pure $ EvalResult (StructLit flLits) (structExpr flEs)
  VarExpr i -> do
    l <- (! i) <$> askLits
    let e' = case isNonAbstract (literalType l) of
               Just IsNonAbs -> LiteralExpr l
               Nothing -> VarExpr i
    pure $ EvalResult l e'
  FieldExpr se i -> do
    -- Since struct expressions can be abstract, we must be careful to keep
    -- everything lazy here! In particular, we don't want to force `sl` below
    -- to evaluate. (See the second comment in the `ApplyExpr` case below.)
    EvalResult sl se' <- evalExpr se
    let l  = case sl of
               StructLit fls -> fieldInstValue (fls ! i)
        e' = case se' of
               StructExpr fls -> fieldInstValue (fls ! i)
               LiteralExpr (StructLit fls) | IsNonAbs <- nonAbstractIndex fls i
                 -> LiteralExpr (fieldInstValue (fls ! i))
               _  -> FieldExpr se' i
    pure $ EvalResult l e'
  ApplyExpr fi es -> do
    -- We must be careful to keep everything lazy here! In particular, we only
    -- want to evaluate `argLits` if we get a cache miss and this function's
    -- return type is non-abstract. (See the comment below.)
    fn <- (! fi) <$> askImpls
    evalArgs <- traverseFC evalExpr es
    let argLits = fmapFC evalResultLit  evalArgs
        argEs   = fmapFC evalResultExpr evalArgs
    cache <- askCache
    res <- liftST $ lookup cache (FunctionCall fi argEs)
    case (res, isNonAbstract (functionRetType (cfunType (fnImplCFun fn)))) of
      (Just l, Just IsNonAbs) -> pure $ litEvalResult l 
      (Just l, Nothing)       -> pure $ EvalResult l (ApplyExpr fi argEs)
      -- We always cache new function calls with non-abstract return types
      (Nothing, Just IsNonAbs) -> do
        (l, outp) <- callFn fi argLits argEs
        liftST $ insert cache (FunctionCall fi argEs) l
        tellResult (FunctionCallResult fi argEs l outp)
        pure $ litEvalResult l
      -- We don't cache new function calls with non-abstract return types, but
      -- they may still appear in the arguments of some other cached call. To
      -- ensure a concrete function is not evaluated if it is later found to
      -- be part of a cached call, we make sure to call 'callFnLazy' instead
      -- of 'callFn' here, and elsewhere never evauate literals of abstract
      -- type unless they're the arguments to a new function call with
      -- non-abstract return type.
      (Nothing, Nothing) -> do
        l <- fst <$> callFnLazy fi argLits argEs
        pure $ EvalResult l (ApplyExpr fi argEs)
  EqExpr e1 e2 -> do
    EvalResult l1 _ <- evalExpr e1
    EvalResult l2 _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (litEq l1 l2))
  NeqExpr e1 e2 -> do
    EvalResult l1 _ <- evalExpr e1
    EvalResult l2 _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (not $ litEq l1 l2))
  LteExpr e1 e2 -> do
    EvalResult (IntLit x1) _ <- evalExpr e1
    EvalResult (IntLit x2) _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (x1 <= x2))
  LtExpr e1 e2 -> do
    EvalResult (IntLit x1) _ <- evalExpr e1
    EvalResult (IntLit x2) _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (x1 < x2))
  GteExpr e1 e2 -> do
    EvalResult (IntLit x1) _ <- evalExpr e1
    EvalResult (IntLit x2) _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (x1 >= x2))
  GtExpr e1 e2 -> do
    EvalResult (IntLit x1) _ <- evalExpr e1
    EvalResult (IntLit x2) _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (x1 > x2))
  PlusExpr e1 e2 -> do
    EvalResult (IntLit x1) _ <- evalExpr e1
    EvalResult (IntLit x2) _ <- evalExpr e2
    pure $ litEvalResult (IntLit (x1 + x2))
  MinusExpr e1 e2 -> do
    EvalResult (IntLit x1) _ <- evalExpr e1
    EvalResult (IntLit x2) _ <- evalExpr e2
    pure $ litEvalResult (IntLit (x1 - x2))
  TimesExpr e1 e2 -> do
    EvalResult (IntLit x1) _ <- evalExpr e1
    EvalResult (IntLit x2) _ <- evalExpr e2
    pure $ litEvalResult (IntLit (x1 * x2))
  DivExpr e1 e2 -> do
    EvalResult (IntLit x1) _ <- evalExpr e1
    EvalResult (IntLit x2) _ <- evalExpr e2
    pure $ litEvalResult (IntLit (x1 `div` x2))
  ModExpr e1 e2 -> do
    EvalResult (IntLit x1) _ <- evalExpr e1
    EvalResult (IntLit x2) _ <- evalExpr e2
    pure $ litEvalResult (IntLit (x1 `mod` x2))
  AbsExpr e' -> do
    EvalResult (IntLit x) _ <- evalExpr e'
    pure $ litEvalResult (IntLit (abs x))
  NegExpr e' -> do
    EvalResult (IntLit x) _ <- evalExpr e'
    pure $ litEvalResult (IntLit (- x))
  MemberExpr e1 e2 -> do
    EvalResult (EnumLit _ i) _ <- evalExpr e1
    EvalResult (SetLit _ s) _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (isJust (find (== Some i) s)))
  NotMemberExpr e1 e2 -> do
    EvalResult (EnumLit _ i) _ <- evalExpr e1
    EvalResult (SetLit _ s) _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (isNothing (find (== Some i) s)))
  SubsetExpr e1 e2 -> do
    EvalResult (SetLit _ s1) _ <- evalExpr e1
    EvalResult (SetLit _ s2) _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (s1 `intersect` s2 == s1))
  NonEmptyExpr e' -> do
    EvalResult (SetLit _ s) _ <- evalExpr e'
    pure $ litEvalResult (BoolLit (not (null s)))
  SizeExpr e' -> do
    EvalResult (SetLit _ s) _ <- evalExpr e'
    pure $ litEvalResult (IntLit (fromIntegral (length s)))
  IntersectExpr e1 e2 -> do
    EvalResult (SetLit cs s1) _ <- evalExpr e1
    EvalResult (SetLit _ s2) _ <- evalExpr e2
    pure $ litEvalResult (SetLit cs (s1 `intersect` s2))
  UnionExpr e1 e2 -> do
    EvalResult (SetLit cs s1) _ <- evalExpr e1
    EvalResult (SetLit _ s2) _ <- evalExpr e2
    pure $ litEvalResult (SetLit cs (s1 `union` s2))
  SymDiffExpr e1 e2 -> do
    EvalResult (SetLit cs s1) _ <- evalExpr e1
    EvalResult (SetLit _ s2) _ <- evalExpr e2
    pure $ litEvalResult (SetLit cs ((s1 \\ s2) `union` (s2 \\ s1)))
  DiffExpr e1 e2 -> do
    EvalResult (SetLit cs s1) _ <- evalExpr e1
    EvalResult (SetLit _ s2) _ <- evalExpr e2
    pure $ litEvalResult (SetLit cs (s1 \\ s2))
  ComplementExpr e' -> do
    EvalResult (SetLit cs s) _ <- evalExpr e'
    pure $ litEvalResult (SetLit cs (toListWithIndex (\i _ -> Some i) cs \\ s))
  AndExpr e1 e2 -> do
    EvalResult (BoolLit b1) _ <- evalExpr e1
    EvalResult (BoolLit b2) _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (b1 && b2))
  OrExpr e1 e2 -> do
    EvalResult (BoolLit b1) _ <- evalExpr e1
    EvalResult (BoolLit b2) _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (b1 || b2))
  XorExpr e1 e2 -> do
    EvalResult (BoolLit b1) _ <- evalExpr e1
    EvalResult (BoolLit b2) _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (b1 `xor` b2))
  ImpliesExpr e1 e2 -> do
    EvalResult (BoolLit b1) _ <- evalExpr e1
    EvalResult (BoolLit b2) _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (not b1 || b2))
  IffExpr e1 e2 -> do
    EvalResult (BoolLit b1) _ <- evalExpr e1
    EvalResult (BoolLit b2) _ <- evalExpr e2
    pure $ litEvalResult (BoolLit (b1 == b2))
  NotExpr e' -> do
    EvalResult (BoolLit b) _ <- evalExpr e'
    pure $ litEvalResult (BoolLit (not b))

data EvalFieldResult env ctx p =
  EvalFieldResult { evalResultFieldLit :: FieldInst Literal p
                  , evalResultFieldExpr :: FieldInst (Expr env ctx) p
                  }

evalField :: (MonadFail m, MonadUnliftIO m)
          => FieldInst (Expr env ctx) p
          -> EvalM env ctx m (EvalFieldResult env ctx p)
evalField (FieldInst nm tp e) = do
  EvalResult l e' <- evalExpr e
  pure $ EvalFieldResult (FieldInst nm tp l)
                         (FieldInst nm tp e')

-- | Determine whether a set of constraints are satisfied in the context of
-- literals given by the 'EvalM' monad and return the list of those
-- constraints not satisfied. By "satisfy" we mean evaluate to
-- @'BoolLit' 'True'@ using 'evalExpr'.
getFailingConstraints :: (MonadUnliftIO m, MonadFail m)
                      => [Expr env ctx BoolType]
                      -> EvalM env ctx m [Expr env ctx BoolType]
getFailingConstraints constraints =
  catMaybes <$> traverse failingConstraint constraints
  
failingConstraint :: (MonadUnliftIO m, MonadFail m)
                  => Expr env ctx BoolType
                  -> EvalM env ctx m (Maybe (Expr env ctx BoolType))
failingConstraint e = do
  EvalResult (BoolLit b) _ <- evalExpr e
  pure (if b then Nothing else Just e)